function P = ProfilePrune(P, newL, verbose)
% ProfilePrune   The pruning part of profile update for the Kernel RLS-DLA
%
% Pruning is the most difficult part of profile learning, we must restrict
% size of matrices in profile (X,W,..) and thus reduce how well (new)
% vectors can be approximated by the dictionary in the pruned profile.
% Note that the profile dictionary, and C and Psi, keep its size,
% but the other matrices in profile, U, K, X, and W, are reduced.
% Pruning method A is briefly explained in code comments.
%
%    Pin:         Input profile, before normalization
%    Pout:       Output profile, after normalization
%    newL:      New target size, pruning only if newL < Pin.L
%    verbose:  0: show only errors, 1: (default), and warnings, 2: and more
%
% ex:
% Pa = ProfilePrune(P3, 50, 3, true);
% 
% Generated by Ghasem Alipoor (alipoor@hut.ac.ir) and Karl Skretting (karl.skretting@uis.no)
% Last modification: 5 August 2022
%

method = 'Prune least used in first half of X';

if (nargin < 2)
    error('Must have at least 2 input arguments, see help.');
end
if (nargin < 3) || isempty(verbose)
    verbose = 1;
end
if newL < P.Q
    if verbose > 0
        fprintf('  WARNING: newL = %i < P.Q = %i. ---> newL = P.Q = %i\n', newL, P.Q, P.Q);
    end
    newL = P.Q;
end

if newL < P.L
    if verbose > 1
        fprintf('\n%s: newL = %i, method: %s\n', mfilename(), newL, method);
    end
    
    % find the index of elements to remove
    B = P.U' * P.W;
    b = sum(abs(B'));   % stem(b) shows these
    [~,Tempidx] = sort(b(1:floor(P.L/2)));  % sort the first half
    M = P.L-newL;
    
    % Checking the following two eligibility conditions for the candidate
    % data vectors:
    %         1. The corresponding diagonal element of the denominator matrix
    %             of alpha_m in Eq (37) is not too small
    %          2. After prunning, all rows of P.W at least have a nonzero element.
    idx = [];   % the elements of X (and W) to prune
    keep = 1:P.L;
    while (length(idx) < M) && (~isempty(Tempidx))
        ii = find(P.W(:, Tempidx(1)));
        if (~any((sum(abs(P.W(ii, keep)), 2) - abs(P.W(ii, Tempidx(1)))) < 1e-4)) && ...
                (abs(1 - P.lambda(Tempidx(1))*P.W(:, Tempidx(1))'*P.C*P.W(:, Tempidx(1))) > 1e-3)
            idx = cat(1, idx, Tempidx(1));
            keep = setdiff(1:P.L, idx);
        end
        Tempidx(1) = [];
    end
    
    lambda_m = diag(P.lambda(idx));
    w_m = P.W(:, idx);
    u_m = P.C*w_m; %     Eq. (37)
    %     alpha_m = (eye(M) - lambda_m*w_m'*u_m)\lambda_m; %     Eq. (37)
    A = diag(1./diag(lambda_m)) - w_m'*u_m;
    % Despite checking for above two conditions, the denominator matrix of alpha_m in Eq (37)
    %    may still be non-singular, i.e. A may be ill-conditioned!
    % In following lines, a sub-matrix of the matrix A is selected whose columns (and rows)
    %    are linearly independant. Corresponding data vecctor is deleted from the set of
    %    selected candidate data samples.
    [~, R, E] = qr(A, 0);
    if ~isvector(R)
        diagr = abs(diag(R));
    else
        diagr = R(1);
    end
    r = find(diagr >= 1e-4*diagr(1), 1, 'last'); %rank estimation
    SelIdx = sort(E(1:r));   % Selected indexes
    w_m = w_m(:, SelIdx);
    u_m = u_m(:, SelIdx);
    lambda_m = lambda_m(SelIdx, SelIdx);
    idx = idx(SelIdx);
    M = length(idx);
    
    A = diag(1./diag(lambda_m)) - w_m'*u_m;
    alpha_m = A\eye(M); %     Eq. (37)
    
    keep = setdiff(1:P.L, idx);
    
    k_m = P.K(:, idx);
    sigma_m = P.K(idx, idx);
    
    % remove elements
    P.lambda(idx) = 0;
    
    v_m = diag(P.lambda)*P.W'*u_m;
    u_m_hat = P.U*(k_m*lambda_m - P.K*v_m*alpha_m);
    
    P.C = P.C + u_m*alpha_m*u_m'; %     Eq. (36)
    P.U = P.U + u_m*alpha_m*v_m'; %     Eq. (38)
    if strcmpi(P.KernelType, 'Lin')
        P.D = P.D - (P.X(:, idx) - P.D*w_m)*alpha_m*u_m'; %     Eq. (42)
    end
    Temp1 = u_m*u_m_hat';
    Temp2 = alpha_m*v_m'*k_m*lambda_m;
    P.Psi = P.Psi - (Temp1 + Temp1') ...
        + u_m*(lambda_m*sigma_m*lambda_m - Temp2 - Temp2' + alpha_m*v_m'*P.K*v_m*alpha_m)*u_m'; % Eq. (43)
    
    P.X = P.X(:,keep);
    P.W = P.W(:,keep);
    P.L = size(P.X,2);   % = newL
    P.U = P.U(:,keep);      % gives correct size
    P.K = P.K(keep,keep);
    P.lambda = P.lambda(keep);
    
    if (min(diag(P.Psi)) < 1e-4) || (max(diag(P.Psi)) > 1e4)
        % Hmm dictionary too far from normalized, has happened but very rare
        if verbose
            fprintf('\nWARNING: %s, diag(P.Psi) NOT as it should be!\n',mfilename());
            %             pause(5);
        end
        P = ProfileNormalize(P, verbose);
    end
end
end
