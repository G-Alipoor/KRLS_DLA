function P = ProfileAssert(P, dispWarning)
% ProfileAssert   Update (assert) some matrices in profile for Kernel RLS-DLA
%     Check and correct (modify) P.W and then update
%     matrices C, U, K, (D) and Psi based on definitions and
%     based on values in matrices X, W and Lambda = diag(lambda)
%
% use:  Pout = ProfileAssert(Pin, dispWarning)
%    Pout,Pin     Profile, this is a struct as in ProfileShow()
%    dispWarning  Print warnings if true and warning is appropriate, (default: false)
%
% ex:  Pgood = ProfileAssert(P2);
%
% Generated by Ghasem Alipoor (alipoor@hut.ac.ir) and Karl Skretting (karl.skretting@uis.no)
% Last modification: 13 June 2023
%

rowSumFactor = 1e-6;
minLambda = 1/16;    % minimum value for P.lambda

if (nargin < 1)
    error('Must have at least 1 input argument, see help.');
end
if (nargin < 2) || isempty(dispWarning)
    dispWarning = true;
end

if dispWarning
    % check sizes
    if ~( (size(P.X,1) == P.N) && (size(P.X,2) == P.L))
        fprintf('\n** WARNING %s: size(X) = %ix%i, and NxL = %ix%i\n', mfilename(), size(P.X), P.N, P.L);
    end
    if ~( (size(P.W,1) == P.Q) && (size(P.W,2) == P.L))
        fprintf('\n** WARNING %s: size(W) = %ix%i, and QxL = %ix%i\n', mfilename(), size(P.W), P.Q, P.L);
    end
    if ~( (size(P.lambda,1) == P.L) && (size(P.lambda,2) == 1))
        fprintf('\n** WARNING %s: size(lambda) = %ix%i, and Lx1 = %ix%i\n', mfilename(), size(P.lambda), P.L, 1);
    end
end

if min(P.lambda) < minLambda
    % Since lambda is modified here (and not in ProfileGrow) we can make
    % sure that the profile is correct after adjusting P.lambda (there is
    % probably not any fast (avoiding inverse of or multiplication of large
    % matrices, QxQ or larger). In this functions matrices are updated
    % based on definitions (not recursively, based on previous values).
    if dispWarning
        fprintf('\n** WARNING %s, min(lambda) = %.6f \n',mfilename(),min(P.lambda));
        % fprintf('\n*** WARNING, irregular update of lambda in %s\n',mfilename());
        % ProfileShow(P, true);
        % pause(2);
    end
    % P.lambda(P.lambda < minLambda) = minLambda;   % adjustment below is better.
    P.lambda = sqrt(P.lambda);  % make all entries closer to 1.0
end

if any(any(isnan(P.W)))
    if dispWarning
        fprintf('\n** WARNING %s: %i columns of W has one or more NaNs\n', mfilename(), sum(any(isnan(P.W))));
        fprintf('  --> Set these to 0.0 now. **\n');
    end
    P.W( isnan(P.W) ) = 0.0;
end
% more check of P.W
rowSum = sum(abs(P.W),2);
minOnMax = min(rowSum) / max(rowSum);
if  minOnMax < 1e-6
    % some atoms in dictionary are hardly used
    [~,i1] = sort(rowSum);    % rowSum(i1(1)) is the smallest one
    if dispWarning
        fprintf('\n** WARNING %s: row %i of W has a very small row sum.\n', mfilename(), i1(1));
    end
    maxRowSum = rowSum(i1(P.Q));   % the last in i1,  = rowSum(i1(end));
    % are sizes OK?
    % disp([size(P.W), size(P.U), size(P.C), size(P.K)]);
    if ((P.L == size(P.W,2)) && (P.L == size(P.U,2)) && ...
            (P.L == size(P.K,1)) && (P.L == size(P.K,2)))
        IB = eye(P.L) - P.U' * P.W;
        r2 = diag( IB'*P.K*IB );
    else
        r2 = randn(size(P.W,2), 1);
    end
    [~,i2] = sort(r2);
    %
    for q = i1(:)'    % q: atom number
        if rowSum(q) > (rowSumFactor * maxRowSum)
            break
        end
        i = i2(P.L+1-q);   % the column of W to update
        P.W(:,i) = zeros(P.Q,1);
        P.W(q,i) = max(1.0, 5*rowSumFactor*maxRowSum);    % this should make D(:,q) = phi( X(:,i) )
        if dispWarning
            fprintf('  -> P.W(%i, %i) = %f\n        ', q, i, P.W(q,i) );
        end
    end
end

WL = P.W .* repmat(P.lambda', P.Q, 1);  % .. * diag(P.lambda);   % QxL
WLW = WL * P.W';
if P.Gamma == 0.0
    if condest(WLW) < 1e6
        C = inv( WLW );
    else
        delta = max(0.001*max(abs(diag(WLW))),1e-6);
        if dispWarning
            fprintf('  ** WARNING %s: (W*Lambda*W'') is ill conditioned **\n', mfilename())
            fprintf('  --> Add regularization term %.8f * eye(Q)\n', delta)
        end
        C = inv( WLW + delta*eye(P.Q) );
    end
else
    C = inv( WL * P.W' + P.Gamma*eye(P.Q) );
end
P.C = (C+C')/2;   % make sure it is exactly symmetric (needed?)
P.U = P.C * WL;
% Updating K seems not to be necessary.
if ~isfield(P, 'K') || ~(size(P.K,1) == P.L) || ~(size(P.K,2) == P.L)
    % Update when K is wrong
    P.K = ker_eval(P.X, P.X, P.KernelType, P.KernelParam);   % LxL
end
if strcmpi(P.KernelType, 'Lin')
    P.D = P.X * P.U';   % since Phi matrix in kernel space = P.X
end
Psi = P.U * P.K * P.U';
P.Psi = (Psi+Psi')/2;  % make sure it is exactly symmetric (needed?)
end
